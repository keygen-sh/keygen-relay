// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: licenses.sql

package db

import (
	"context"
)

const claimLicenseFIFO = `-- name: ClaimLicenseFIFO :one
UPDATE licenses
SET node_id = ?, last_claimed_at = unixepoch(), claims = claims + 1
WHERE id = (
    SELECT l.id
    FROM licenses l
    WHERE l.node_id IS NULL AND l.pool_id IS NULL
    ORDER BY l.created_at ASC
    LIMIT 1
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

func (q *Queries) ClaimLicenseFIFO(ctx context.Context, nodeID *int64) (License, error) {
	row := q.db.QueryRowContext(ctx, claimLicenseFIFO, nodeID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const claimLicenseLIFO = `-- name: ClaimLicenseLIFO :one
UPDATE licenses
SET node_id = ?, last_claimed_at = unixepoch(), claims = claims + 1
WHERE id = (
    SELECT l.id
    FROM licenses l
    WHERE l.node_id IS NULL AND l.pool_id IS NULL
    ORDER BY l.created_at DESC
    LIMIT 1
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

func (q *Queries) ClaimLicenseLIFO(ctx context.Context, nodeID *int64) (License, error) {
	row := q.db.QueryRowContext(ctx, claimLicenseLIFO, nodeID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const claimLicenseRandom = `-- name: ClaimLicenseRandom :one
UPDATE licenses
SET node_id = ?, last_claimed_at = unixepoch(), claims = claims + 1
WHERE id = (
    SELECT l.id
    FROM licenses l
    WHERE l.node_id IS NULL AND l.pool_id IS NULL
    ORDER BY RANDOM()
    LIMIT 1
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

func (q *Queries) ClaimLicenseRandom(ctx context.Context, nodeID *int64) (License, error) {
	row := q.db.QueryRowContext(ctx, claimLicenseRandom, nodeID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const claimPooledLicenseFIFO = `-- name: ClaimPooledLicenseFIFO :one
UPDATE licenses
SET node_id = ?, last_claimed_at = unixepoch(), claims = claims + 1
WHERE id = (
    SELECT l.id
    FROM licenses l
    WHERE l.node_id IS NULL AND l.pool_id = ?
    ORDER BY l.created_at ASC
    LIMIT 1
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

type ClaimPooledLicenseFIFOParams struct {
	NodeID *int64
	PoolID *int64
}

func (q *Queries) ClaimPooledLicenseFIFO(ctx context.Context, arg ClaimPooledLicenseFIFOParams) (License, error) {
	row := q.db.QueryRowContext(ctx, claimPooledLicenseFIFO, arg.NodeID, arg.PoolID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const claimPooledLicenseLIFO = `-- name: ClaimPooledLicenseLIFO :one
UPDATE licenses
SET node_id = ?, last_claimed_at = unixepoch(), claims = claims + 1
WHERE id = (
     SELECT l.id
    FROM licenses l
    WHERE l.node_id IS NULL AND l.pool_id = ?
    ORDER BY l.created_at DESC
    LIMIT 1
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

type ClaimPooledLicenseLIFOParams struct {
	NodeID *int64
	PoolID *int64
}

func (q *Queries) ClaimPooledLicenseLIFO(ctx context.Context, arg ClaimPooledLicenseLIFOParams) (License, error) {
	row := q.db.QueryRowContext(ctx, claimPooledLicenseLIFO, arg.NodeID, arg.PoolID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const claimPooledLicenseRandom = `-- name: ClaimPooledLicenseRandom :one
UPDATE licenses
SET node_id = ?, last_claimed_at = unixepoch(), claims = claims + 1
WHERE id = (
    SELECT l.id
    FROM licenses l
    WHERE l.node_id IS NULL AND l.pool_id = ?
    ORDER BY RANDOM()
    LIMIT 1
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

type ClaimPooledLicenseRandomParams struct {
	NodeID *int64
	PoolID *int64
}

func (q *Queries) ClaimPooledLicenseRandom(ctx context.Context, arg ClaimPooledLicenseRandomParams) (License, error) {
	row := q.db.QueryRowContext(ctx, claimPooledLicenseRandom, arg.NodeID, arg.PoolID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLicenseByGUID = `-- name: DeleteLicenseByGUID :one
DELETE FROM licenses
WHERE guid = ?
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

func (q *Queries) DeleteLicenseByGUID(ctx context.Context, guid string) (License, error) {
	row := q.db.QueryRowContext(ctx, deleteLicenseByGUID, guid)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const getAllLicenses = `-- name: GetAllLicenses :many
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
ORDER BY id
`

func (q *Queries) GetAllLicenses(ctx context.Context) ([]License, error) {
	rows, err := q.db.QueryContext(ctx, getAllLicenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []License
	for rows.Next() {
		var i License
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.File,
			&i.Key,
			&i.Claims,
			&i.LastClaimedAt,
			&i.LastReleasedAt,
			&i.NodeID,
			&i.PoolID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLicenseByGUID = `-- name: GetLicenseByGUID :one
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
WHERE guid = ?
`

func (q *Queries) GetLicenseByGUID(ctx context.Context, guid string) (License, error) {
	row := q.db.QueryRowContext(ctx, getLicenseByGUID, guid)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const getLicenseByNodeID = `-- name: GetLicenseByNodeID :one
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
WHERE node_id = ? and pool_id IS NULL
`

func (q *Queries) GetLicenseByNodeID(ctx context.Context, nodeID *int64) (License, error) {
	row := q.db.QueryRowContext(ctx, getLicenseByNodeID, nodeID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const getPooledLicenseByGUID = `-- name: GetPooledLicenseByGUID :one
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
WHERE guid = ? AND pool_id = ?
`

type GetPooledLicenseByGUIDParams struct {
	Guid   string
	PoolID *int64
}

func (q *Queries) GetPooledLicenseByGUID(ctx context.Context, arg GetPooledLicenseByGUIDParams) (License, error) {
	row := q.db.QueryRowContext(ctx, getPooledLicenseByGUID, arg.Guid, arg.PoolID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const getPooledLicenseByNodeID = `-- name: GetPooledLicenseByNodeID :one
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
WHERE node_id = ? AND pool_id = ?
`

type GetPooledLicenseByNodeIDParams struct {
	NodeID *int64
	PoolID *int64
}

func (q *Queries) GetPooledLicenseByNodeID(ctx context.Context, arg GetPooledLicenseByNodeIDParams) (License, error) {
	row := q.db.QueryRowContext(ctx, getPooledLicenseByNodeID, arg.NodeID, arg.PoolID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const getPooledLicenses = `-- name: GetPooledLicenses :many
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
WHERE pool_id = ?
ORDER BY id
`

func (q *Queries) GetPooledLicenses(ctx context.Context, poolID *int64) ([]License, error) {
	rows, err := q.db.QueryContext(ctx, getPooledLicenses, poolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []License
	for rows.Next() {
		var i License
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.File,
			&i.Key,
			&i.Claims,
			&i.LastClaimedAt,
			&i.LastReleasedAt,
			&i.NodeID,
			&i.PoolID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpooledLicenseByGUID = `-- name: GetUnpooledLicenseByGUID :one
SELECT id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
FROM licenses
WHERE guid = ? and pool_id IS NULL
`

func (q *Queries) GetUnpooledLicenseByGUID(ctx context.Context, guid string) (License, error) {
	row := q.db.QueryRowContext(ctx, getUnpooledLicenseByGUID, guid)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const insertLicense = `-- name: InsertLicense :one
INSERT INTO licenses (pool_id, guid, file, key)
VALUES (?, ?, ?, ?)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

type InsertLicenseParams struct {
	PoolID *int64
	Guid   string
	File   []byte
	Key    string
}

func (q *Queries) InsertLicense(ctx context.Context, arg InsertLicenseParams) (License, error) {
	row := q.db.QueryRowContext(ctx, insertLicense,
		arg.PoolID,
		arg.Guid,
		arg.File,
		arg.Key,
	)
	var i License
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
		&i.PoolID,
		&i.CreatedAt,
	)
	return i, err
}

const releaseLicenseByNodeID = `-- name: ReleaseLicenseByNodeID :exec
UPDATE licenses
SET node_id = NULL, last_released_at = unixepoch()
WHERE node_id = ? AND pool_id IS NULL
`

func (q *Queries) ReleaseLicenseByNodeID(ctx context.Context, nodeID *int64) error {
	_, err := q.db.ExecContext(ctx, releaseLicenseByNodeID, nodeID)
	return err
}

const releaseLicensesFromDeadNodes = `-- name: ReleaseLicensesFromDeadNodes :many
UPDATE licenses
SET node_id = NULL, last_released_at = unixepoch()
WHERE node_id IN (
    SELECT id FROM nodes
    WHERE last_heartbeat_at <= strftime('%s', 'now', ?) AND deactivated_at IS NULL
)
RETURNING id, guid, file, "key", claims, last_claimed_at, last_released_at, node_id, pool_id, created_at
`

func (q *Queries) ReleaseLicensesFromDeadNodes(ctx context.Context, strftime interface{}) ([]License, error) {
	rows, err := q.db.QueryContext(ctx, releaseLicensesFromDeadNodes, strftime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []License
	for rows.Next() {
		var i License
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.File,
			&i.Key,
			&i.Claims,
			&i.LastClaimedAt,
			&i.LastReleasedAt,
			&i.NodeID,
			&i.PoolID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releasePooledLicenseByNodeID = `-- name: ReleasePooledLicenseByNodeID :exec
UPDATE licenses
SET node_id = NULL, last_released_at = unixepoch()
WHERE node_id = ? AND pool_id = ?
`

type ReleasePooledLicenseByNodeIDParams struct {
	NodeID *int64
	PoolID *int64
}

func (q *Queries) ReleasePooledLicenseByNodeID(ctx context.Context, arg ReleasePooledLicenseByNodeIDParams) error {
	_, err := q.db.ExecContext(ctx, releasePooledLicenseByNodeID, arg.NodeID, arg.PoolID)
	return err
}
